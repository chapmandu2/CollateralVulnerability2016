#' BISEP Analysis
#'
#' The BISEP analysis function identifies genes with bimodel expression profiles.  See \code{\link[BiSEp]{BiSEp}} documentation.
#' Note that the version of BISEP used is slightly modified and not that from the BiSEp package -
#' see \code{\link{BISEP_cv}} for more details.
#'
#' @param con A \code{SQLiteConnection} object
#' @param genes_n Permits a random subsample of genes to be analysed rather than the full set.  Default 100000 - ie all.
#' @param table_name The table in the SQLite database containing the data.  The table should have fields named
#'   patient_id, gene_id and value where gene_id is an ensembl id.  Default tcga_rnaseq_data
#' @param log2_transform Boolean operator to determine whether data should be log2 transformed.  Default \code{TRUE}
#' @param gene_var_th Genes with very low variance can cause BISEP to fail.  Increasing the gene variance
#'   threshold parameter can filter out these genes.  Default 0.2
#' @param gene_naprop_th Genes with a higih proportion of NA values can cause BISEP to fail.  Decreasing
#'   the proportion of NA's filter can filter out these genes.  Default 0.3.
#' @param seed_val Setting this parameter ensures that consistent BISEP p-values are returned from run
#'   to run but there is no parallelisation so the analysis will take longer.
#'   See \code{\link{set.seed}} for more details.  Default is NULL - no seed set.
#' @return A data frame
#' @export
#' @importFrom foreach %dopar% %do%
doBISEPAnalysis <- function(con, genes_n=100000, table_name='tcga_rnaseq_data', log2_transform=TRUE, gene_var_th=0.2, gene_naprop_th=0.3, seed_val=NULL) {

    message('Get RNAseq data and reformat')
    rnaseq_mat_df <-  dplyr::src_sqlite(my_con@dbname) %>%
        dplyr::tbl(table_name) %>%
        dplyr::select(patient_id, gene_id, value) %>%
        dplyr::collect() %>%
        dplyr::mutate(value=ifelse(value==0, NA, value)) %>%
        tidyr::spread(patient_id, value) %>%
        as.data.frame()
    dim(rnaseq_mat_df)

    message('Convert data into matrix')
    rnaseq_mat <- rnaseq_mat_df
    rownames(rnaseq_mat) <- rnaseq_mat$gene_id
    rnaseq_mat <- rnaseq_mat[,-1]
    rnaseq_mat <- as.matrix(rnaseq_mat)
    if(log2_transform) {rnaseq_mat <- log2(rnaseq_mat)}

    #work out the variance and proportion of NA's for each gene
    gene_vars <- apply(rnaseq_mat, 1, var, na.rm=TRUE)
    gene_naprop <- apply(rnaseq_mat, 1, function(x) sum(is.na(x))/length(x))

    #set up parallel processing
    n_cores <- parallel::detectCores()
    cl <- parallel::makeCluster(n_cores)
    doParallel::registerDoParallel(cl)

    #try BISEP on genes with a sufficiently high variance
    x <- which(gene_vars>gene_var_th & gene_naprop<gene_naprop_th)  #col ids of genes to use

    #sampling of gene ids for testing - since BISEP can take a long time, option to just look at a subset of genes
    if(genes_n <= length(x)) {
        set.seed(56789)
        x <- sample(x, genes_n)
    }

    #list of vectors to parallelise across
    set.seed(12345)
    x_list <- split(x, sample(1:n_cores, length(x), replace=TRUE))

    #parallelise BISEP analysis using list of vectors to split up work
    #DON'T parallelise if seed_val is set as results not consistent
    #bisep_out will be a list of bisep result objects
    message(sprintf('Running BiSEp on %s genes...', length(x)))

    if(!is.null(seed_val)) {
        message("seed_val set so parallelisation OFF (slower) but p-values consistent run to run")
        bisep_out <- foreach::foreach(i=1:n_cores) %do%
            BISEP_cv(rnaseq_mat[x_list[[i]], ], seed_val=seed_val)
    } else {
        message("seed_val NOT set so parallelisation ON (faster) but p-values NOT consistent run to run")
        bisep_out <- foreach::foreach(i=1:n_cores) %dopar%
            BISEP_cv(rnaseq_mat[x_list[[i]], ])
    }

    message('Finished BiSEp: processing results')

    parallel::stopCluster(cl)

    #extract out BI results from list of BISEP objects into a single data frame
    biIndex <- lapply(bisep_out, function(z) dplyr::add_rownames(z$BI, 'gene_id')) %>%
        dplyr::bind_rows()

    #extract out BISEP results from list of BISEP objects into a single data frame
    bisepIndex <- lapply(bisep_out, function(z) dplyr::add_rownames(z$BISEP, 'gene_id')) %>%
        dplyr::bind_rows()

    #join BISEP results together and include gene info
    all_genes <- dplyr::src_sqlite(con@dbname) %>%
        dplyr::tbl('human_genes') %>%
        dplyr::collect() %>%
        dplyr::select(gene_id, gene_name)

    bisep_results <- biIndex %>%
        dplyr::inner_join(bisepIndex, by='gene_id') %>%
        dplyr::inner_join(all_genes, by='gene_id') %>%
        dplyr::rename(pi_value = pi, bisep_pval = V2) %>%
        dplyr::select(gene_id, gene_name, everything()) %>%
        as.data.frame()

    message('Writing results to database')
    DBI::dbWriteTable(con, 'bisep_results', bisep_results, overwrite=TRUE)

    message('Finished!')
    return(bisep_results)

}
